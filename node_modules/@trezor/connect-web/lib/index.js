"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("events"));
const ERRORS = tslib_1.__importStar(require("@trezor/connect/lib/constants/errors"));
const events_2 = require("@trezor/connect/lib/events");
const factory_1 = require("@trezor/connect/lib/factory");
const debug_1 = require("@trezor/connect/lib/utils/debug");
const config_1 = require("@trezor/connect/lib/data/config");
const utils_1 = require("@trezor/utils");
const iframe = tslib_1.__importStar(require("./iframe"));
const popup = tslib_1.__importStar(require("./popup"));
const button_1 = tslib_1.__importDefault(require("./webusb/button"));
const connectSettings_1 = require("./connectSettings");
const eventEmitter = new events_1.default();
const _log = (0, debug_1.initLog)('@trezor/connect-web');
let _settings = (0, connectSettings_1.parseConnectSettings)();
let _popupManager;
const messagePromises = (0, utils_1.createDeferredManager)({ initialId: 1 });
const initPopupManager = () => {
    const pm = new popup.PopupManager(_settings, { logger: _log });
    pm.on(events_2.POPUP.CLOSED, (error) => {
        iframe.postMessage({
            type: events_2.POPUP.CLOSED,
            payload: error ? { error } : null,
        });
    });
    return pm;
};
const manifest = (data) => {
    _settings = (0, connectSettings_1.parseConnectSettings)(Object.assign(Object.assign({}, _settings), { manifest: data }));
};
const dispose = () => {
    eventEmitter.removeAllListeners();
    iframe.dispose();
    _settings = (0, connectSettings_1.parseConnectSettings)();
    if (_popupManager) {
        _popupManager.close();
    }
    return Promise.resolve(undefined);
};
const cancel = (error) => {
    if (_popupManager) {
        _popupManager.emit(events_2.POPUP.CLOSED, error);
    }
};
const handleMessage = (messageEvent) => {
    if (messageEvent.origin !== iframe.origin)
        return;
    const message = (0, events_2.parseMessage)(messageEvent.data);
    _log.log('handleMessage', message);
    switch (message.event) {
        case events_2.RESPONSE_EVENT: {
            const { id = 0, success, payload } = message;
            const resolved = messagePromises.resolve(id, { id, success, payload });
            if (!resolved)
                _log.warn(`Unknown message id ${id}`);
            break;
        }
        case events_2.DEVICE_EVENT:
            eventEmitter.emit(message.event, message);
            eventEmitter.emit(message.type, message.payload);
            break;
        case events_2.TRANSPORT_EVENT:
            eventEmitter.emit(message.event, message);
            eventEmitter.emit(message.type, message.payload);
            break;
        case events_2.BLOCKCHAIN_EVENT:
            eventEmitter.emit(message.event, message);
            eventEmitter.emit(message.type, message.payload);
            break;
        case events_2.UI_EVENT:
            if (message.type === events_2.IFRAME.BOOTSTRAP) {
                iframe.clearTimeout();
                break;
            }
            if (message.type === events_2.IFRAME.LOADED) {
                iframe.initPromise.resolve();
            }
            if (message.type === events_2.IFRAME.ERROR) {
                iframe.initPromise.reject(message.payload.error);
            }
            eventEmitter.emit(message.event, message);
            eventEmitter.emit(message.type, message.payload);
            break;
        default:
            _log.log('Undefined message', messageEvent.data);
    }
};
const init = async (settings = {}) => {
    var _a;
    if (iframe.instance) {
        throw ERRORS.TypedError('Init_AlreadyInitialized');
    }
    _settings = (0, connectSettings_1.parseConnectSettings)(Object.assign(Object.assign({}, _settings), settings));
    if (!_settings.manifest) {
        throw ERRORS.TypedError('Init_ManifestMissing');
    }
    if (!((_a = _settings.transports) === null || _a === void 0 ? void 0 : _a.length)) {
        _settings.transports = ['BridgeTransport', 'WebUsbTransport'];
    }
    if (_settings.lazyLoad) {
        _settings.lazyLoad = false;
        return;
    }
    if (!_popupManager) {
        _popupManager = initPopupManager();
    }
    _log.enabled = !!_settings.debug;
    window.addEventListener('message', handleMessage);
    window.addEventListener('unload', dispose);
    await iframe.init(_settings);
    if (_settings.sharedLogger !== false) {
        iframe.initIframeLogger();
    }
};
const call = async (params) => {
    if (!iframe.instance && !iframe.timeout) {
        _settings = (0, connectSettings_1.parseConnectSettings)(_settings);
        if (!_settings.manifest) {
            return (0, events_2.createErrorMessage)(ERRORS.TypedError('Init_ManifestMissing'));
        }
        if (!_popupManager) {
            _popupManager = initPopupManager();
        }
        _popupManager.request();
        try {
            await init(_settings);
        }
        catch (error) {
            if (_popupManager) {
                if (['Init_IframeBlocked', 'Init_IframeTimeout'].includes(error.code)) {
                    _popupManager.postMessage((0, events_2.createUiMessage)(events_2.UI.IFRAME_FAILURE));
                }
                else {
                    _popupManager.clear();
                }
            }
            return (0, events_2.createErrorMessage)(error);
        }
    }
    if (iframe.timeout) {
        return (0, events_2.createErrorMessage)(ERRORS.TypedError('Init_ManifestMissing'));
    }
    if (iframe.error) {
        return (0, events_2.createErrorMessage)(iframe.error);
    }
    if (_settings.popup && _popupManager) {
        _popupManager.request();
    }
    try {
        const { promiseId, promise } = messagePromises.create();
        iframe.postMessage({ id: promiseId, type: events_2.IFRAME.CALL, payload: params });
        const response = await promise;
        if (response) {
            if (!response.success &&
                response.payload.code !== 'Device_CallInProgress' &&
                _popupManager) {
                _popupManager.unlock();
            }
            return response;
        }
        if (_popupManager) {
            _popupManager.unlock();
        }
        return (0, events_2.createErrorMessage)(ERRORS.TypedError('Method_NoResponse'));
    }
    catch (error) {
        _log.error('__call error', error);
        if (_popupManager) {
            _popupManager.clear(false);
        }
        return (0, events_2.createErrorMessage)(error);
    }
};
const uiResponse = (response) => {
    if (!iframe.instance) {
        throw ERRORS.TypedError('Init_NotInitialized');
    }
    iframe.postMessage(response);
};
const renderWebUSBButton = (className) => {
    (0, button_1.default)(className, _settings.webusbSrc);
};
const requestLogin = async (params) => {
    if (typeof params.callback === 'function') {
        const { callback } = params;
        const loginChallengeListener = async (event) => {
            const { data } = event;
            if (data && data.type === events_2.UI.LOGIN_CHALLENGE_REQUEST) {
                try {
                    const payload = await callback();
                    iframe.postMessage({
                        type: events_2.UI.LOGIN_CHALLENGE_RESPONSE,
                        payload,
                    });
                }
                catch (error) {
                    iframe.postMessage({
                        type: events_2.UI.LOGIN_CHALLENGE_RESPONSE,
                        payload: error.message,
                    });
                }
            }
        };
        window.addEventListener('message', loginChallengeListener, false);
        const response = await call(Object.assign(Object.assign({ method: 'requestLogin' }, params), { asyncChallenge: true, callback: null }));
        window.removeEventListener('message', loginChallengeListener);
        return response;
    }
    return call(Object.assign({ method: 'requestLogin' }, params));
};
const disableWebUSB = () => {
    if (!iframe.instance) {
        throw ERRORS.TypedError('Init_NotInitialized');
    }
    iframe.postMessage({ type: events_2.TRANSPORT.DISABLE_WEBUSB });
};
const requestWebUSBDevice = async () => {
    try {
        await window.navigator.usb.requestDevice({ filters: config_1.config.webusb });
        iframe.postMessage({ type: events_2.TRANSPORT.REQUEST_DEVICE });
    }
    catch (_err) {
    }
};
const TrezorConnect = (0, factory_1.factory)({
    eventEmitter,
    manifest,
    init,
    call,
    requestLogin,
    uiResponse,
    renderWebUSBButton,
    disableWebUSB,
    requestWebUSBDevice,
    cancel,
    dispose,
});
exports.default = TrezorConnect;
tslib_1.__exportStar(require("@trezor/connect/lib/exports"), exports);
//# sourceMappingURL=index.js.map