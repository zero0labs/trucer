"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const AbstractMethod_1 = require("../core/AbstractMethod");
const firmware_1 = require("./firmware");
const firmwareInfo_1 = require("../data/firmwareInfo");
const constants_1 = require("../constants");
const assets_1 = require("../utils/assets");
const types_1 = require("../types");
class CheckFirmwareAuthenticity extends AbstractMethod_1.AbstractMethod {
    init() {
        this.useEmptyPassphrase = true;
        this.requiredPermissions = ['management'];
        this.useDeviceState = false;
    }
    async run() {
        var _a;
        const { device } = this;
        const firmwareVersion = `${device.features.major_version}.${device.features.minor_version}.${device.features.patch_version}`;
        const releases = (0, firmwareInfo_1.getReleases)((_a = device.features) === null || _a === void 0 ? void 0 : _a.internal_model);
        const release = releases.find(release => release.version.join('.') === firmwareVersion);
        if (!release) {
            throw constants_1.ERRORS.TypedError('Runtime', 'checkFirmwareAuthenticity: No release found for device firmware');
        }
        const deviceModelPath = `${device.features.internal_model}`.toLowerCase();
        const baseUrl = `https://data.trezor.io/firmware/${deviceModelPath}`;
        const fwUrl = `${baseUrl}/trezor-${deviceModelPath}-${firmwareVersion}${device.firmwareType === types_1.FirmwareType.BitcoinOnly ? '-bitcoinonly.bin' : '.bin'}`;
        const fw = await (0, assets_1.httpRequest)(fwUrl, 'binary');
        if (!fw) {
            throw constants_1.ERRORS.TypedError('Runtime', 'checkFirmwareAuthenticity: firmware binary not found');
        }
        const { hash: expectedFirmwareHash, challenge } = (0, firmware_1.calculateFirmwareHash)(device.features.major_version, (0, firmware_1.stripFwHeaders)(fw), (0, crypto_1.randomBytes)(32));
        const result = await this.device
            .getCommands()
            .typedCall('GetFirmwareHash', 'FirmwareHash', {
            challenge,
        });
        const { message } = result;
        const { hash: actualFirmwareHash } = message;
        return {
            expectedFirmwareHash,
            actualFirmwareHash,
            valid: actualFirmwareHash === expectedFirmwareHash,
        };
    }
}
exports.default = CheckFirmwareAuthenticity;
//# sourceMappingURL=checkFirmwareAuthenticity.js.map