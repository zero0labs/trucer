"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractMethod = exports.DEFAULT_FIRMWARE_RANGE = void 0;
const connect_common_1 = require("@trezor/connect-common");
const utils_1 = require("@trezor/utils");
const DataManager_1 = require("../data/DataManager");
const constants_1 = require("../constants");
const events_1 = require("../events");
const urlUtils_1 = require("../utils/urlUtils");
exports.DEFAULT_FIRMWARE_RANGE = {
    T1B1: { min: '1.0.0', max: '0' },
    T2T1: { min: '2.0.0', max: '0' },
    T2B1: { min: '2.6.1', max: '0' },
};
class AbstractMethod {
    get info() {
        return '';
    }
    constructor(message) {
        var _a, _b;
        const { payload } = message;
        this.name = payload.method;
        this.payload = payload;
        this.responseID = message.id || 0;
        this.devicePath = (_a = payload.device) === null || _a === void 0 ? void 0 : _a.path;
        this.deviceState = (_b = payload.device) === null || _b === void 0 ? void 0 : _b.state;
        this.hasExpectedDeviceState = payload.device
            ? Object.prototype.hasOwnProperty.call(payload.device, 'state')
            : false;
        this.keepSession = typeof payload.keepSession === 'boolean' ? payload.keepSession : false;
        this.skipFinalReload =
            typeof payload.skipFinalReload === 'boolean' ? payload.skipFinalReload : false;
        this.skipFirmwareCheck = false;
        this.overridePreviousCall =
            typeof payload.override === 'boolean' ? payload.override : false;
        this.overridden = false;
        this.useEmptyPassphrase =
            typeof payload.useEmptyPassphrase === 'boolean' ? payload.useEmptyPassphrase : false;
        this.allowSeedlessDevice =
            typeof payload.allowSeedlessDevice === 'boolean' ? payload.allowSeedlessDevice : false;
        this.allowDeviceMode = [];
        this.requireDeviceMode = [];
        if (this.allowSeedlessDevice) {
            this.allowDeviceMode = [events_1.UI.SEEDLESS];
        }
        this.network = 'bitcoin';
        Object.keys(constants_1.NETWORK.TYPES).forEach(key => {
            if (this.name.startsWith(key)) {
                this.network = key;
            }
        });
        this.firmwareRange = exports.DEFAULT_FIRMWARE_RANGE;
        this.requiredPermissions = [];
        this.useDevice = true;
        this.useDeviceState = true;
        this.useUi = true;
        this.useCardanoDerivation =
            typeof payload.useCardanoDerivation === 'boolean'
                ? payload.useCardanoDerivation
                : payload.method.startsWith('cardano');
    }
    setDevice(device) {
        this.device = device;
        this.devicePath = device.getDevicePath();
        const originalFn = this.createUiPromise;
        this.createUiPromise = (t, d) => originalFn(t, d || device);
    }
    async requestPermissions() {
        await this.getPopupPromise().promise;
        const uiPromise = this.createUiPromise(events_1.UI.RECEIVE_PERMISSION);
        this.postMessage((0, events_1.createUiMessage)(events_1.UI.REQUEST_PERMISSION, {
            permissions: this.requiredPermissions,
            device: this.device.toMessageObject(),
        }));
        const uiResp = await uiPromise.promise;
        const { granted, remember } = uiResp.payload;
        if (granted) {
            this.savePermissions(!remember);
            return true;
        }
        return false;
    }
    getOriginPermissions() {
        var _a;
        const origin = DataManager_1.DataManager.getSettings('origin');
        if (!origin) {
            return [];
        }
        return ((_a = connect_common_1.storage.loadForOrigin(origin)) === null || _a === void 0 ? void 0 : _a.permissions) || [];
    }
    checkPermissions() {
        const originPermissions = this.getOriginPermissions();
        let notPermitted = [...this.requiredPermissions];
        if (originPermissions.length > 0) {
            notPermitted = notPermitted.filter(np => {
                const granted = originPermissions.find(p => p.type === np && p.device === this.device.features.device_id);
                return !granted;
            });
        }
        this.requiredPermissions = notPermitted;
    }
    savePermissions(temporary = false) {
        const originPermissions = this.getOriginPermissions();
        let permissionsToSave = this.requiredPermissions.map(p => ({
            type: p,
            device: this.device.features.device_id || undefined,
        }));
        let emitEvent = false;
        if (this.requiredPermissions.indexOf('read') >= 0) {
            const wasAlreadyGranted = originPermissions.filter(p => p.type === 'read' && p.device === this.device.features.device_id);
            if (wasAlreadyGranted.length < 1) {
                emitEvent = true;
            }
        }
        if (originPermissions.length > 0) {
            permissionsToSave = permissionsToSave.filter(p2s => {
                const granted = originPermissions.find(p => p.type === p2s.type && p.device === p2s.device);
                return !granted;
            });
        }
        const origin = DataManager_1.DataManager.getSettings('origin');
        connect_common_1.storage.saveForOrigin(state => ({
            ...state,
            permissions: [...(state.permissions || []), ...permissionsToSave],
        }), origin, temporary);
        if (emitEvent) {
            this.postMessage((0, events_1.createDeviceMessage)(events_1.DEVICE.CONNECT, this.device.toMessageObject()));
        }
    }
    async checkFirmwareRange(isUsingPopup) {
        if (this.skipFirmwareCheck) {
            return;
        }
        const { device } = this;
        if (!device.features || device.isBootloader())
            return;
        const range = this.firmwareRange[device.features.internal_model];
        if (device.firmwareStatus === 'none') {
            return events_1.UI.FIRMWARE_NOT_INSTALLED;
        }
        if (!range) {
            return;
        }
        if (range.min === '0') {
            return events_1.UI.FIRMWARE_NOT_SUPPORTED;
        }
        const version = device.getVersion().join('.');
        if (device.firmwareStatus === 'required' ||
            !utils_1.versionUtils.isNewerOrEqual(version, range.min)) {
            return events_1.UI.FIRMWARE_OLD;
        }
        if (range.max !== '0' && utils_1.versionUtils.isNewer(version, range.max)) {
            if (isUsingPopup) {
                await this.getPopupPromise().promise;
                const uiPromise = this.createUiPromise(events_1.UI.RECEIVE_CONFIRMATION);
                this.postMessage((0, events_1.createUiMessage)(events_1.UI.FIRMWARE_NOT_COMPATIBLE, device.toMessageObject()));
                const uiResp = await uiPromise.promise;
                if (!uiResp.payload) {
                    throw constants_1.ERRORS.TypedError('Method_PermissionsNotGranted');
                }
            }
            else {
                return events_1.UI.FIRMWARE_NOT_COMPATIBLE;
            }
        }
    }
    isManagementRestricted() {
        const { popup, origin } = DataManager_1.DataManager.getSettings();
        if (popup && this.requiredPermissions.includes('management')) {
            const host = (0, urlUtils_1.getHost)(origin);
            const allowed = DataManager_1.DataManager.getConfig().management.find(item => item.origin === host || item.origin === origin);
            return !allowed;
        }
    }
    dispose() { }
}
exports.AbstractMethod = AbstractMethod;
//# sourceMappingURL=AbstractMethod.js.map