"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initCore = exports.Core = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("events"));
const transport_1 = require("@trezor/transport");
const utils_1 = require("@trezor/utils");
const utils_2 = require("@trezor/utils");
const connect_common_1 = require("@trezor/connect-common");
const DataManager_1 = require("../data/DataManager");
const DeviceList_1 = require("../device/DeviceList");
const analyticsInfo_1 = require("../data/analyticsInfo");
const constants_1 = require("../constants");
const events_2 = require("../events");
const method_1 = require("./method");
const promiseUtils_1 = require("../utils/promiseUtils");
const debug_1 = require("../utils/debug");
const BlockchainLink_1 = require("../backend/BlockchainLink");
const interactionTimeout_1 = require("../utils/interactionTimeout");
let _core;
let _deviceList;
let _popupPromise;
const _uiPromises = [];
const _callMethods = [];
let _interactionTimeout;
let _deviceListInitTimeout;
let _overridePromise;
const methodSynchronize = (0, utils_2.getSynchronize)();
let waitForFirstMethod = (0, utils_1.createDeferred)();
const _log = (0, debug_1.initLog)('Core');
const postMessage = (message) => {
    if (message.event === events_2.RESPONSE_EVENT) {
        const index = _callMethods.findIndex(call => call && call.responseID === message.id);
        if (index >= 0) {
            _callMethods.splice(index, 1);
            if (_callMethods.length === 0) {
                waitForFirstMethod = (0, utils_1.createDeferred)();
            }
        }
    }
    _core.emit(events_2.CORE_EVENT, message);
};
const getPopupPromise = (requestWindow = true) => {
    if (requestWindow) {
        postMessage((0, events_2.createUiMessage)(events_2.UI.REQUEST_UI_WINDOW));
    }
    if (!_popupPromise) {
        _popupPromise = (0, utils_1.createDeferred)();
    }
    return _popupPromise;
};
const interactionTimeout = () => _interactionTimeout.start(() => {
    onPopupClosed('Interaction timeout');
});
const createUiPromise = (promiseEvent, device) => {
    const uiPromise = {
        ...(0, utils_1.createDeferred)(promiseEvent),
        device,
    };
    _uiPromises.push(uiPromise);
    interactionTimeout();
    return uiPromise;
};
const findUiPromise = (promiseEvent) => _uiPromises.find(p => p.id === promiseEvent);
const removeUiPromise = (promise) => {
    _uiPromises.splice(0).push(..._uiPromises.filter(p => p !== promise));
};
const handleMessage = (message) => {
    _log.debug('handleMessage', message);
    switch (message.type) {
        case events_2.POPUP.HANDSHAKE:
            getPopupPromise(false).resolve();
            break;
        case events_2.POPUP.CLOSED:
            onPopupClosed(message.payload ? message.payload.error : null);
            break;
        case transport_1.TRANSPORT.DISABLE_WEBUSB:
            disableWebUSBTransport();
            break;
        case transport_1.TRANSPORT.REQUEST_DEVICE:
            _deviceList === null || _deviceList === void 0 ? void 0 : _deviceList.enumerate();
            break;
        case events_2.UI.RECEIVE_DEVICE:
        case events_2.UI.RECEIVE_CONFIRMATION:
        case events_2.UI.RECEIVE_PERMISSION:
        case events_2.UI.RECEIVE_PIN:
        case events_2.UI.RECEIVE_PASSPHRASE:
        case events_2.UI.INVALID_PASSPHRASE_ACTION:
        case events_2.UI.RECEIVE_ACCOUNT:
        case events_2.UI.RECEIVE_FEE:
        case events_2.UI.RECEIVE_WORD:
        case events_2.UI.LOGIN_CHALLENGE_RESPONSE: {
            const uiPromise = findUiPromise(message.type);
            if (uiPromise) {
                uiPromise.resolve(message);
                removeUiPromise(uiPromise);
            }
            break;
        }
        case events_2.IFRAME.CALL:
            onCall(message).catch(error => {
                _log.error('onCall', error);
            });
            break;
    }
};
const initDevice = async (method) => {
    if (!_deviceList) {
        throw constants_1.ERRORS.TypedError('Transport_Missing');
    }
    await _deviceList.transportFirstEventPromise;
    const isWebUsb = _deviceList.transportType() === 'WebUsbTransport';
    let device;
    let showDeviceSelection = isWebUsb;
    const isUsingPopup = DataManager_1.DataManager.getSettings('popup');
    const origin = DataManager_1.DataManager.getSettings('origin');
    const useCoreInPopup = DataManager_1.DataManager.getSettings('useCoreInPopup');
    const { preferredDevice } = connect_common_1.storage.load().origin[origin] || {};
    const preferredDeviceInList = preferredDevice && _deviceList.getDevice(preferredDevice.path);
    if (preferredDevice && !preferredDeviceInList) {
        connect_common_1.storage.save(store => {
            store.origin[origin] = { ...store.origin[origin], preferredDevice: undefined };
            return store;
        });
    }
    if (method.devicePath) {
        device = _deviceList.getDevice(method.devicePath);
        showDeviceSelection =
            !device || !!(device === null || device === void 0 ? void 0 : device.unreadableError) || (device.isUnacquired() && !!isUsingPopup);
    }
    else {
        const devices = _deviceList.asArray();
        if (devices.length === 1 && (!isWebUsb || !isUsingPopup)) {
            device = _deviceList.getDevice(devices[0].path);
            showDeviceSelection =
                !!(device === null || device === void 0 ? void 0 : device.unreadableError) || device.isUnacquired() || !!useCoreInPopup;
        }
        else {
            showDeviceSelection = true;
        }
    }
    if (showDeviceSelection) {
        createUiPromise(events_2.UI.RECEIVE_DEVICE);
        await getPopupPromise().promise;
        if (!_deviceList) {
            throw constants_1.ERRORS.TypedError('Transport_Missing');
        }
        const devices = _deviceList.asArray();
        if (devices.length === 1 &&
            devices[0].type !== 'unreadable' &&
            devices[0].features &&
            !isWebUsb) {
            device = _deviceList.getDevice(devices[0].path);
        }
        else {
            postMessage((0, events_2.createUiMessage)(events_2.UI.SELECT_DEVICE, {
                webusb: isWebUsb,
                devices: _deviceList.asArray(),
            }));
            const uiPromise = findUiPromise(events_2.UI.RECEIVE_DEVICE);
            if (uiPromise) {
                const { payload } = await uiPromise.promise;
                if (payload.remember) {
                    const { label, path, state } = payload.device;
                    connect_common_1.storage.save(store => {
                        store.origin[origin] = {
                            ...store.origin[origin],
                            preferredDevice: { label, path, state },
                        };
                        return store;
                    });
                }
                device = _deviceList.getDevice(payload.device.path);
            }
        }
    }
    if (!device) {
        throw constants_1.ERRORS.TypedError('Device_NotFound');
    }
    return device;
};
const onCall = async (message) => {
    var _a;
    if (!message.id || !message.payload || message.type !== events_2.IFRAME.CALL) {
        throw constants_1.ERRORS.TypedError('Method_InvalidParameter', 'onCall: message.id or message.payload is missing');
    }
    const responseID = message.id;
    const trustedHost = DataManager_1.DataManager.getSettings('trustedHost');
    const isUsingPopup = DataManager_1.DataManager.getSettings('popup');
    const origin = DataManager_1.DataManager.getSettings('origin');
    const env = DataManager_1.DataManager.getSettings('env');
    const useCoreInPopup = DataManager_1.DataManager.getSettings('useCoreInPopup');
    const { preferredDevice } = connect_common_1.storage.loadForOrigin(origin) || {};
    if (preferredDevice && !message.payload.device) {
        message.payload.device = preferredDevice;
    }
    let method;
    let messageResponse;
    try {
        method = await methodSynchronize(async () => {
            var _a;
            _log.debug('loading method...');
            const method = await (0, method_1.getMethod)(message);
            _log.debug('method selected', method.name);
            method.postMessage = postMessage;
            method.getPopupPromise = getPopupPromise;
            method.createUiPromise = createUiPromise;
            method.init();
            await ((_a = method.initAsync) === null || _a === void 0 ? void 0 : _a.call(method));
            return method;
        });
        waitForFirstMethod.resolve();
        _callMethods.push(method);
    }
    catch (error) {
        postMessage((0, events_2.createPopupMessage)(events_2.POPUP.CANCEL_POPUP_REQUEST));
        postMessage((0, events_2.createResponseMessage)(responseID, false, { error }));
        return Promise.resolve();
    }
    if (!method.useDevice) {
        try {
            if (method.useUi) {
                await getPopupPromise().promise;
            }
            else {
                postMessage((0, events_2.createPopupMessage)(events_2.POPUP.CANCEL_POPUP_REQUEST));
            }
            const response = await method.run();
            messageResponse = (0, events_2.createResponseMessage)(method.responseID, true, response);
        }
        catch (error) {
            messageResponse = (0, events_2.createResponseMessage)(method.responseID, false, { error });
        }
        postMessage(messageResponse);
        return Promise.resolve();
    }
    if (!_deviceList && !DataManager_1.DataManager.getSettings('transportReconnect')) {
        await initDeviceList(false);
    }
    if (method.isManagementRestricted()) {
        postMessage((0, events_2.createPopupMessage)(events_2.POPUP.CANCEL_POPUP_REQUEST));
        postMessage((0, events_2.createResponseMessage)(responseID, false, {
            error: constants_1.ERRORS.TypedError('Method_NotAllowed'),
        }));
        return Promise.resolve();
    }
    let device;
    try {
        device = await initDevice(method);
    }
    catch (error) {
        if (error.code === 'Transport_Missing') {
            await getPopupPromise().promise;
            postMessage((0, events_2.createUiMessage)(events_2.UI.TRANSPORT));
        }
        else {
            postMessage((0, events_2.createPopupMessage)(events_2.POPUP.CANCEL_POPUP_REQUEST));
        }
        postMessage((0, events_2.createResponseMessage)(responseID, false, { error }));
        throw error;
    }
    method.postMessage = (message) => (0, analyticsInfo_1.enhancePostMessageWithAnalytics)(postMessage, message, { device: device.toMessageObject() });
    method.setDevice(device);
    const previousCall = _callMethods.filter(call => call && call !== method && call.devicePath === method.devicePath);
    if (previousCall.length > 0 && method.overridePreviousCall) {
        previousCall.forEach(call => {
            call.overridden = true;
        });
        const overrideError = constants_1.ERRORS.TypedError('Method_Override');
        _overridePromise = device.override(overrideError);
        await _overridePromise;
        if (method.overridden) {
            postMessage((0, events_2.createResponseMessage)(method.responseID, false, { error: overrideError }));
            throw overrideError;
        }
    }
    else if (device.isRunning()) {
        if (!device.isLoaded()) {
            await device.waitForFirstRun();
        }
        else {
            postMessage((0, events_2.createResponseMessage)(responseID, false, {
                error: constants_1.ERRORS.TypedError('Device_CallInProgress'),
            }));
            throw constants_1.ERRORS.TypedError('Device_CallInProgress');
        }
    }
    device.setInstance((_a = message.payload.device) === null || _a === void 0 ? void 0 : _a.instance);
    if (method.hasExpectedDeviceState) {
        device.setExternalState(method.deviceState);
    }
    device.on(events_2.DEVICE.BUTTON, (d, code) => {
        onDeviceButtonHandler(d, code, method);
    });
    device.on(events_2.DEVICE.PIN, onDevicePinHandler);
    device.on(events_2.DEVICE.WORD, onDeviceWordHandler);
    device.on(events_2.DEVICE.PASSPHRASE, method.useEmptyPassphrase ? onEmptyPassphraseHandler : onDevicePassphraseHandler);
    device.on(events_2.DEVICE.PASSPHRASE_ON_DEVICE, () => {
        postMessage((0, events_2.createUiMessage)(events_2.UI.REQUEST_PASSPHRASE_ON_DEVICE, { device: device.toMessageObject() }));
    });
    device.on(events_2.DEVICE.SAVE_STATE, (state) => {
        connect_common_1.storage.saveForOrigin(store => {
            if (useCoreInPopup && env === 'webextension') {
                return {
                    ...store,
                    preferredDevice: store.preferredDevice
                        ? {
                            ...store.preferredDevice,
                            internalState: state,
                            internalStateExpiration: Date.now() + 1000 * 60 * 15,
                        }
                        : undefined,
                };
            }
            return store;
        }, origin);
    });
    if (!device.getInternalState() && useCoreInPopup && env === 'webextension') {
        const { preferredDevice } = connect_common_1.storage.loadForOrigin(origin) || {};
        if ((preferredDevice === null || preferredDevice === void 0 ? void 0 : preferredDevice.internalState) &&
            (preferredDevice === null || preferredDevice === void 0 ? void 0 : preferredDevice.internalStateExpiration) &&
            preferredDevice.internalStateExpiration > new Date().getTime()) {
            device.setInternalState(preferredDevice.internalState);
        }
    }
    try {
        let PIN_TRIES = 1;
        const MAX_PIN_TRIES = 3;
        const inner = async () => {
            const firmwareException = await method.checkFirmwareRange(isUsingPopup);
            if (firmwareException) {
                if (isUsingPopup) {
                    await getPopupPromise().promise;
                    postMessage((0, events_2.createUiMessage)(firmwareException, device.toMessageObject()));
                    await createUiPromise(events_2.DEVICE.DISCONNECT, device).promise;
                    return Promise.reject(constants_1.ERRORS.TypedError('Method_Cancel'));
                }
                return Promise.reject(constants_1.ERRORS.TypedError('Device_FwException', firmwareException));
            }
            const unexpectedMode = device.hasUnexpectedMode(method.allowDeviceMode, method.requireDeviceMode);
            if (unexpectedMode) {
                device.keepSession = false;
                if (isUsingPopup) {
                    await getPopupPromise().promise;
                    postMessage((0, events_2.createUiMessage)(unexpectedMode, device.toMessageObject()));
                    await createUiPromise(events_2.DEVICE.DISCONNECT, device).promise;
                    return Promise.reject(constants_1.ERRORS.TypedError('Device_ModeException', unexpectedMode));
                }
                return Promise.reject(constants_1.ERRORS.TypedError('Device_ModeException', unexpectedMode));
            }
            method.checkPermissions();
            if (!trustedHost && method.requiredPermissions.length > 0) {
                const permitted = await method.requestPermissions();
                if (!permitted) {
                    return Promise.reject(constants_1.ERRORS.TypedError('Method_PermissionsNotGranted'));
                }
            }
            const deviceNeedsBackup = device.features.needs_backup;
            if (deviceNeedsBackup && typeof method.noBackupConfirmation === 'function') {
                const permitted = await method.noBackupConfirmation(!isUsingPopup);
                if (!permitted) {
                    return Promise.reject(constants_1.ERRORS.TypedError('Method_PermissionsNotGranted'));
                }
            }
            if (deviceNeedsBackup) {
                await getPopupPromise().promise;
                postMessage((0, events_2.createUiMessage)(events_2.UI.DEVICE_NEEDS_BACKUP, device.toMessageObject()));
            }
            if (device.firmwareStatus === 'outdated') {
                await getPopupPromise().promise;
                postMessage((0, events_2.createUiMessage)(events_2.UI.FIRMWARE_OUTDATED, device.toMessageObject()));
            }
            if (!trustedHost && typeof method.confirmation === 'function') {
                const confirmed = await method.confirmation();
                if (!confirmed) {
                    return Promise.reject(constants_1.ERRORS.TypedError('Method_Cancel'));
                }
            }
            const isDeviceUnlocked = device.features.unlocked;
            try {
                const invalidDeviceState = method.useDeviceState
                    ? await device.validateState(method.network, method.preauthorized)
                    : undefined;
                if (invalidDeviceState) {
                    if (isUsingPopup) {
                        const uiPromise = createUiPromise(events_2.UI.INVALID_PASSPHRASE_ACTION, device);
                        postMessage((0, events_2.createUiMessage)(events_2.UI.INVALID_PASSPHRASE, {
                            device: device.toMessageObject(),
                        }));
                        const uiResp = await uiPromise.promise;
                        if (uiResp.payload) {
                            device.setInternalState(undefined);
                            await device.initialize(method.useEmptyPassphrase, method.useCardanoDerivation);
                            return inner();
                        }
                        device.setExternalState(invalidDeviceState);
                    }
                    else {
                        throw constants_1.ERRORS.TypedError('Device_InvalidState');
                    }
                }
            }
            catch (error) {
                if (error.message.includes('PIN invalid') && PIN_TRIES < MAX_PIN_TRIES) {
                    PIN_TRIES++;
                    postMessage((0, events_2.createUiMessage)(events_2.UI.INVALID_PIN, { device: device.toMessageObject() }));
                    return inner();
                }
                device.setInternalState(undefined);
                return Promise.reject(error);
            }
            if (!isDeviceUnlocked && device.features.unlocked) {
                postMessage((0, events_2.createDeviceMessage)(events_2.DEVICE.CHANGED, device.toMessageObject()));
            }
            if (method.useUi) {
                await getPopupPromise().promise;
            }
            else {
                postMessage((0, events_2.createPopupMessage)(events_2.POPUP.CANCEL_POPUP_REQUEST));
            }
            try {
                const response = await method.run();
                messageResponse = (0, events_2.createResponseMessage)(method.responseID, true, response);
            }
            catch (error) {
                return Promise.reject(error);
            }
        };
        if (_overridePromise) {
            await _overridePromise;
        }
        await device.run(inner, {
            keepSession: method.keepSession,
            useEmptyPassphrase: method.useEmptyPassphrase,
            skipFinalReload: method.skipFinalReload,
            useCardanoDerivation: method.useCardanoDerivation,
        });
    }
    catch (error) {
        if (_deviceList && error.code === 'Device_Disconnected') {
            _deviceList.addAuthPenalty(device);
        }
        if (method) {
            if (_deviceList && error.message === transport_1.TRANSPORT_ERROR.SESSION_WRONG_PREVIOUS) {
                await _deviceList.enumerate();
            }
            messageResponse = (0, events_2.createResponseMessage)(method.responseID, false, { error });
        }
    }
    finally {
        if (_overridePromise) {
            await _overridePromise;
        }
        const response = messageResponse;
        if (response) {
            if (method.name === 'rebootToBootloader' && response.success) {
                await (0, promiseUtils_1.resolveAfter)(1000).promise;
                try {
                    await device.run(() => Promise.resolve(), { skipFinalReload: true });
                }
                catch (err) {
                }
            }
            await device.cleanup();
            closePopup();
            cleanup();
            if (method) {
                method.dispose();
            }
            if (_deviceList) {
                if (response.success) {
                    _deviceList.removeAuthPenalty(device);
                }
            }
            postMessage(response);
        }
    }
};
const cleanup = () => {
    _popupPromise = undefined;
    _uiPromises.splice(0);
    _interactionTimeout.stop();
    _log.debug('Cleanup...');
};
const closePopup = () => {
    if (_popupPromise) {
        postMessage((0, events_2.createPopupMessage)(events_2.POPUP.CANCEL_POPUP_REQUEST));
    }
    postMessage((0, events_2.createUiMessage)(events_2.UI.CLOSE_UI_WINDOW));
};
const onDeviceButtonHandler = async (...[device, request, method]) => {
    const addressRequest = request.code === 'ButtonRequest_Address';
    if (!addressRequest || (addressRequest && method.useUi)) {
        await getPopupPromise().promise;
    }
    const data = typeof method.getButtonRequestData === 'function' && request.code
        ? method.getButtonRequestData(request.code)
        : undefined;
    interactionTimeout();
    postMessage((0, events_2.createDeviceMessage)(events_2.DEVICE.BUTTON, { ...request, device: device.toMessageObject() }));
    postMessage((0, events_2.createUiMessage)(events_2.UI.REQUEST_BUTTON, {
        ...request,
        device: device.toMessageObject(),
        data,
    }));
    if (addressRequest && !method.useUi) {
        postMessage((0, events_2.createUiMessage)(events_2.UI.ADDRESS_VALIDATION, data));
    }
};
const onDevicePinHandler = async (...[device, type, callback]) => {
    await getPopupPromise().promise;
    const uiPromise = createUiPromise(events_2.UI.RECEIVE_PIN, device);
    postMessage((0, events_2.createUiMessage)(events_2.UI.REQUEST_PIN, { device: device.toMessageObject(), type }));
    const uiResp = await uiPromise.promise;
    callback(null, uiResp.payload);
};
const onDeviceWordHandler = async (...[device, type, callback]) => {
    await getPopupPromise().promise;
    const uiPromise = createUiPromise(events_2.UI.RECEIVE_WORD, device);
    postMessage((0, events_2.createUiMessage)(events_2.UI.REQUEST_WORD, { device: device.toMessageObject(), type }));
    const uiResp = await uiPromise.promise;
    callback(null, uiResp.payload);
};
const onDevicePassphraseHandler = async (...[device, callback]) => {
    await getPopupPromise().promise;
    const uiPromise = createUiPromise(events_2.UI.RECEIVE_PASSPHRASE, device);
    postMessage((0, events_2.createUiMessage)(events_2.UI.REQUEST_PASSPHRASE, { device: device.toMessageObject() }));
    const uiResp = await uiPromise.promise;
    const { value, passphraseOnDevice, save } = uiResp.payload;
    callback({
        passphrase: value.normalize('NFKD'),
        passphraseOnDevice,
        cache: save,
    });
};
const onEmptyPassphraseHandler = (...[_, callback]) => {
    callback({ passphrase: '' });
};
const onPopupClosed = (customErrorMessage) => {
    const error = customErrorMessage
        ? constants_1.ERRORS.TypedError('Method_Cancel', customErrorMessage)
        : constants_1.ERRORS.TypedError('Method_Interrupted');
    if (_deviceList && _deviceList.asArray().length > 0) {
        _deviceList.allDevices().forEach(d => {
            d.keepSession = false;
            if (d.isUsedHere()) {
                _overridePromise = d.interruptionFromUser(error);
            }
            else {
                const uiPromise = findUiPromise(events_2.DEVICE.DISCONNECT);
                if (uiPromise) {
                    uiPromise.resolve({ type: events_2.DEVICE.DISCONNECT, payload: undefined });
                }
                else {
                    _callMethods.forEach(m => {
                        postMessage((0, events_2.createResponseMessage)(m.responseID, false, { error }));
                    });
                    _callMethods.splice(0, _callMethods.length);
                    waitForFirstMethod = (0, utils_1.createDeferred)();
                }
            }
        });
        cleanup();
    }
    else {
        if (_uiPromises.length > 0) {
            _uiPromises.forEach(p => {
                p.reject(error);
            });
            _uiPromises.splice(0);
        }
        if (_popupPromise) {
            _popupPromise.reject(error);
            _popupPromise = undefined;
        }
        cleanup();
    }
};
const handleDeviceSelectionChanges = (interruptDevice) => {
    const uiPromise = findUiPromise(events_2.UI.RECEIVE_DEVICE);
    if (uiPromise && _deviceList) {
        const list = _deviceList.asArray();
        const isWebUsb = _deviceList.transportType() === 'WebUsbTransport';
        if (list.length === 1 && !isWebUsb) {
            uiPromise.resolve({
                type: events_2.UI.RECEIVE_DEVICE,
                payload: { device: list[0] },
            });
            removeUiPromise(uiPromise);
        }
        else {
            postMessage((0, events_2.createUiMessage)(events_2.UI.SELECT_DEVICE, {
                webusb: isWebUsb,
                devices: list,
            }));
        }
    }
    if (interruptDevice) {
        const { path } = interruptDevice;
        let shouldClosePopup = false;
        _uiPromises.forEach(p => {
            if (p.device && p.device.getDevicePath() === path) {
                if (p.id === events_2.DEVICE.DISCONNECT) {
                    p.resolve({ type: events_2.DEVICE.DISCONNECT });
                }
                shouldClosePopup = true;
            }
        });
        if (shouldClosePopup) {
            closePopup();
            cleanup();
        }
    }
};
const initDeviceList = async (transportReconnect) => {
    try {
        _deviceList = new DeviceList_1.DeviceList();
        _deviceList.on(events_2.DEVICE.CONNECT, device => {
            handleDeviceSelectionChanges();
            postMessage((0, events_2.createDeviceMessage)(events_2.DEVICE.CONNECT, device));
        });
        _deviceList.on(events_2.DEVICE.CONNECT_UNACQUIRED, device => {
            handleDeviceSelectionChanges();
            postMessage((0, events_2.createDeviceMessage)(events_2.DEVICE.CONNECT_UNACQUIRED, device));
        });
        _deviceList.on(events_2.DEVICE.DISCONNECT, device => {
            handleDeviceSelectionChanges(device);
            postMessage((0, events_2.createDeviceMessage)(events_2.DEVICE.DISCONNECT, device));
        });
        _deviceList.on(events_2.DEVICE.CHANGED, device => {
            postMessage((0, events_2.createDeviceMessage)(events_2.DEVICE.CHANGED, device));
        });
        _deviceList.on(transport_1.TRANSPORT.ERROR, error => {
            _log.warn('TRANSPORT.ERROR', error);
            if (_deviceList) {
                _deviceList.disconnectDevices();
                _deviceList.dispose();
            }
            _deviceList = undefined;
            postMessage((0, events_2.createTransportMessage)(transport_1.TRANSPORT.ERROR, { error }));
            if (transportReconnect) {
                const { promise, timeout } = (0, promiseUtils_1.resolveAfter)(1000, null);
                _deviceListInitTimeout = timeout;
                promise.then(() => {
                    initDeviceList(transportReconnect);
                });
            }
        });
        _deviceList.on(transport_1.TRANSPORT.START, transportType => postMessage((0, events_2.createTransportMessage)(transport_1.TRANSPORT.START, transportType)));
        _deviceList.init();
        if (_deviceList) {
            await _deviceList.waitForTransportFirstEvent();
        }
    }
    catch (error) {
        _deviceList = undefined;
        postMessage((0, events_2.createTransportMessage)(transport_1.TRANSPORT.ERROR, { error }));
        if (!transportReconnect) {
            throw error;
        }
        else {
            const { promise, timeout } = (0, promiseUtils_1.resolveAfter)(3000, null);
            _deviceListInitTimeout = timeout;
            await promise;
            await initDeviceList(transportReconnect);
        }
    }
};
class Core extends events_1.default {
    handleMessage(message) {
        handleMessage(message);
    }
    async dispose() {
        (0, BlockchainLink_1.dispose)();
        if (_deviceListInitTimeout) {
            clearTimeout(_deviceListInitTimeout);
        }
        this.removeAllListeners();
        if (_deviceList) {
            await _deviceList.dispose();
        }
    }
    async getCurrentMethod() {
        await waitForFirstMethod.promise;
        return await methodSynchronize(() => _callMethods[0]);
    }
    getTransportInfo() {
        if (!_deviceList) {
            return undefined;
        }
        return _deviceList.getTransportInfo();
    }
    enumerate() {
        if (!_deviceList) {
            return;
        }
        _deviceList.enumerate();
    }
}
exports.Core = Core;
const initCore = async (settings, onCoreEvent, logWriterFactory) => {
    if (logWriterFactory) {
        (0, debug_1.setLogWriter)(logWriterFactory);
    }
    try {
        await DataManager_1.DataManager.load(settings);
        (0, debug_1.enableLog)(DataManager_1.DataManager.getSettings('debug'));
        _core = new Core();
        _interactionTimeout = new interactionTimeout_1.InteractionTimeout(settings.popup ? settings.interactionTimeout : 0);
        _core.on(events_2.CORE_EVENT, onCoreEvent);
    }
    catch (error) {
        _log.error('init', error);
        throw error;
    }
    try {
        if (!DataManager_1.DataManager.getSettings('transportReconnect')) {
            await initDeviceList(false);
        }
        else {
            initDeviceList(true);
        }
    }
    catch (error) {
        _log.error('initTransport', error);
        throw error;
    }
    return _core;
};
exports.initCore = initCore;
const disableWebUSBTransport = async () => {
    var _a;
    if (!_deviceList)
        return;
    if (_deviceList.transportType() !== 'WebUsbTransport')
        return;
    const settings = DataManager_1.DataManager.getSettings();
    if (settings.transports) {
        const transportStr = (_a = settings.transports) === null || _a === void 0 ? void 0 : _a.filter(transport => typeof transport !== 'object');
        if (transportStr.includes('WebUsbTransport')) {
            settings.transports.splice(settings.transports.indexOf('WebUsbTransport'), 1);
        }
        if (!transportStr.includes('BridgeTransport')) {
            settings.transports.unshift('BridgeTransport');
        }
    }
    try {
        await _deviceList.dispose();
        await initDeviceList(settings.transportReconnect);
    }
    catch (error) {
    }
};
//# sourceMappingURL=index.js.map