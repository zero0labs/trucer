"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Device = void 0;
const utils_1 = require("@trezor/utils");
const utils_2 = require("@trezor/utils");
const utils_3 = require("@trezor/utils");
const protocol_1 = require("@trezor/protocol");
const DeviceCommands_1 = require("./DeviceCommands");
const constants_1 = require("../constants");
const events_1 = require("../events");
const coinInfo_1 = require("../data/coinInfo");
const firmwareInfo_1 = require("../data/firmwareInfo");
const deviceFeaturesUtils_1 = require("../utils/deviceFeaturesUtils");
const debug_1 = require("../utils/debug");
const types_1 = require("../types");
const models_1 = require("../data/models");
const _log = (0, debug_1.initLog)('Device');
const parseRunOptions = (options) => {
    if (!options)
        options = {};
    return options;
};
class Device extends utils_1.TypedEmitter {
    constructor(transport, descriptor) {
        super();
        this.featuresNeedsReload = false;
        this.acquirePromise = undefined;
        this.releasePromise = undefined;
        this.loaded = false;
        this.inconsistent = false;
        this.keepSession = false;
        this.instance = 0;
        this.internalState = [];
        this.externalState = [];
        this.unavailableCapabilities = {};
        this.networkTypeState = [];
        this.name = 'Trezor';
        this.availableTranslations = [];
        if (transport.name === 'BridgeTransport') {
            this.protocol = protocol_1.bridge;
        }
        else {
            this.protocol = protocol_1.v1;
        }
        this.transport = transport;
        this.originalDescriptor = descriptor;
        this.firstRunPromise = (0, utils_2.createDeferred)();
    }
    static fromDescriptor(transport, originalDescriptor) {
        const descriptor = { ...originalDescriptor, session: null };
        try {
            const device = new Device(transport, descriptor);
            return device;
        }
        catch (error) {
            _log.error('Device.fromDescriptor', error);
            throw error;
        }
    }
    static createUnacquired(transport, descriptor, unreadableError) {
        const device = new Device(transport, descriptor);
        device.unreadableError = unreadableError;
        return device;
    }
    async acquire() {
        this.acquirePromise = this.transport.acquire({
            input: {
                path: this.originalDescriptor.path,
                previous: this.originalDescriptor.session,
            },
        });
        const acquireResult = await this.acquirePromise.promise;
        this.acquirePromise = undefined;
        if (!acquireResult.success) {
            if (this.runPromise) {
                this.runPromise.reject(new Error(acquireResult.error));
                delete this.runPromise;
            }
            throw acquireResult.error;
        }
        const sessionID = acquireResult.payload;
        _log.debug('Expected session id:', sessionID);
        this.activitySessionID = sessionID;
        this.originalDescriptor.session = sessionID;
        if (this.commands) {
            this.commands.dispose();
        }
        this.commands = new DeviceCommands_1.DeviceCommands(this, this.transport, sessionID);
    }
    async release() {
        if (this.isUsedHere() &&
            !this.keepSession &&
            this.activitySessionID &&
            !this.releasePromise) {
            if (this.commands) {
                this.commands.dispose();
                if (this.commands.callPromise) {
                    await this.commands.callPromise.promise;
                }
            }
            if (this.releasePromise) {
                await this.releasePromise;
            }
            this.releasePromise = this.transport.release({
                session: this.activitySessionID,
                path: this.originalDescriptor.path,
            });
            const releaseResponse = await this.releasePromise.promise;
            this.releasePromise = undefined;
            if (releaseResponse.success) {
                this.activitySessionID = null;
                this.originalDescriptor.session = null;
            }
        }
    }
    async cleanup() {
        this.removeAllListeners();
        delete this.runPromise;
        await this.release();
    }
    run(fn, options) {
        if (this.runPromise) {
            _log.warn('Previous call is still running');
            throw constants_1.ERRORS.TypedError('Device_CallInProgress');
        }
        options = parseRunOptions(options);
        const runPromise = (0, utils_2.createDeferred)();
        this.runPromise = runPromise;
        this._runInner(fn, options).catch(err => {
            runPromise.reject(err);
        });
        return runPromise.promise;
    }
    async override(error) {
        if (this.acquirePromise) {
            await this.acquirePromise.promise;
        }
        if (this.runPromise) {
            await this.interruptionFromUser(error);
        }
        if (this.releasePromise) {
            await this.releasePromise.promise;
        }
    }
    async interruptionFromUser(error) {
        _log.debug('interruptionFromUser');
        if (this.runPromise) {
            this.runPromise.reject(error);
            delete this.runPromise;
        }
        if (this.commands) {
            await this.commands.cancel();
        }
    }
    interruptionFromOutside() {
        _log.debug('interruptionFromOutside');
        if (this.commands) {
            this.commands.dispose();
        }
        if (this.runPromise) {
            this.runPromise.reject(constants_1.ERRORS.TypedError('Device_UsedElsewhere'));
            delete this.runPromise;
        }
        this.transport.releaseDevice(this.originalDescriptor.path);
    }
    async _runInner(fn, options) {
        var _a;
        if (this.releasePromise) {
            await this.releasePromise.promise;
        }
        if (!this.isUsedHere() || ((_a = this.commands) === null || _a === void 0 ? void 0 : _a.disposed) || !this.getExternalState()) {
            await this.acquire();
            try {
                if (fn) {
                    await this.initialize(!!options.useEmptyPassphrase, !!options.useCardanoDerivation);
                }
                else {
                    await Promise.race([
                        this.getFeatures(),
                        new Promise((_resolve, reject) => setTimeout(() => reject(new Error('GetFeatures timeout')), 3000)),
                    ]);
                }
            }
            catch (error) {
                if (!this.inconsistent && error.message === 'GetFeatures timeout') {
                    this.inconsistent = true;
                    return this._runInner(() => Promise.resolve({}), options);
                }
                this.inconsistent = true;
                delete this.runPromise;
                return Promise.reject(constants_1.ERRORS.TypedError('Device_InitializeFailed', `Initialize failed: ${error.message} ${error.code ? `, code: ${error.code}` : ''}`));
            }
        }
        if (options.keepSession) {
            this.keepSession = true;
        }
        if (this.listeners(events_1.DEVICE.ACQUIRED).length > 0) {
            this.emit(events_1.DEVICE.ACQUIRED);
        }
        if (fn) {
            await fn();
        }
        if (this.loaded && this.features && !options.skipFinalReload) {
            await this.getFeatures();
        }
        if ((!this.keepSession && typeof options.keepSession !== 'boolean') ||
            options.keepSession === false) {
            this.keepSession = false;
            await this.release();
        }
        if (this.runPromise) {
            this.runPromise.resolve();
        }
        delete this.runPromise;
        if (!this.loaded) {
            this.loaded = true;
            this.firstRunPromise.resolve(true);
        }
    }
    getCommands() {
        if (!this.commands) {
            throw constants_1.ERRORS.TypedError('Runtime', `Device: commands not defined`);
        }
        return this.commands;
    }
    setInstance(instance = 0) {
        if (this.instance !== instance) {
            if (this.keepSession) {
                this.activitySessionID = null;
                this.keepSession = false;
            }
            if (this.isT1() && this.useLegacyPassphrase()) {
                this.setInternalState(undefined);
            }
        }
        this.instance = instance;
    }
    getInstance() {
        return this.instance;
    }
    setInternalState(state) {
        if (typeof state !== 'string') {
            delete this.internalState[this.instance];
        }
        else if (state !== this.internalState[this.instance]) {
            this.internalState[this.instance] = state;
            this.emit(events_1.DEVICE.SAVE_STATE, state);
        }
    }
    getInternalState() {
        return this.internalState[this.instance];
    }
    setExternalState(state) {
        if (typeof state !== 'string') {
            delete this.internalState[this.instance];
            delete this.externalState[this.instance];
        }
        else {
            this.externalState[this.instance] = state;
        }
    }
    getExternalState() {
        return this.externalState[this.instance];
    }
    async validateState(networkType, preauthorized = false) {
        if (!this.features)
            return;
        if (!this.features.unlocked && preauthorized) {
            if (await this.getCommands().preauthorize(false)) {
                return;
            }
        }
        const expectedState = this.getExternalState();
        const state = await this.getCommands().getDeviceState(networkType);
        const uniqueState = `${state}@${this.features.device_id || 'device_id'}:${this.instance}`;
        if (!this.useLegacyPassphrase() && this.features.session_id) {
            this.setInternalState(this.features.session_id);
        }
        if (expectedState && expectedState !== uniqueState) {
            return uniqueState;
        }
        if (!expectedState) {
            this.setExternalState(uniqueState);
        }
    }
    useLegacyPassphrase() {
        return !this.atLeast(['1.9.0', '2.3.0']);
    }
    async initialize(useEmptyPassphrase, useCardanoDerivation) {
        let payload;
        if (this.features) {
            const legacy = this.useLegacyPassphrase();
            const internalState = this.getInternalState();
            payload = {};
            payload.derive_cardano = useCardanoDerivation;
            if (!legacy && internalState) {
                payload.session_id = internalState;
            }
            if (legacy && !this.isT1()) {
                payload.session_id = internalState;
                if (useEmptyPassphrase) {
                    payload._skip_passphrase = useEmptyPassphrase;
                    payload.session_id = undefined;
                }
            }
        }
        const { message } = await this.getCommands().typedCall('Initialize', 'Features', payload);
        this._updateFeatures(message);
    }
    async getFeatures() {
        const { message } = await this.getCommands().typedCall('GetFeatures', 'Features', {});
        this._updateFeatures(message);
    }
    _updateFeatures(feat) {
        var _a, _b, _c, _d;
        const capabilities = (0, deviceFeaturesUtils_1.parseCapabilities)(feat);
        feat.capabilities = capabilities;
        if (this.features && this.features.session_id && !feat.session_id) {
            feat.session_id = this.features.session_id;
        }
        feat.unlocked = (_a = feat.unlocked) !== null && _a !== void 0 ? _a : true;
        const revision = (0, deviceFeaturesUtils_1.parseRevision)(feat);
        feat.revision = revision;
        if (!feat.model && feat.major_version === 1) {
            feat.model = '1';
        }
        if (!feat.internal_model) {
            feat.internal_model = (0, deviceFeaturesUtils_1.ensureInternalModelFeature)(feat.model);
        }
        const version = [
            feat.major_version,
            feat.minor_version,
            feat.patch_version,
        ];
        if (!utils_3.versionUtils.isEqual(version, this.getVersion())) {
            this.unavailableCapabilities = (0, deviceFeaturesUtils_1.getUnavailableCapabilities)(feat, (0, coinInfo_1.getAllNetworks)());
            this.firmwareStatus = (0, firmwareInfo_1.getFirmwareStatus)(feat);
            this.firmwareRelease = (0, firmwareInfo_1.getRelease)(feat);
            this.availableTranslations = (_c = (_b = this.firmwareRelease) === null || _b === void 0 ? void 0 : _b.translations) !== null && _c !== void 0 ? _c : [];
        }
        this.features = feat;
        this.featuresNeedsReload = false;
        if (feat.fw_vendor === 'Trezor Bitcoin-only') {
            this.firmwareType = types_1.FirmwareType.BitcoinOnly;
        }
        else if (feat.fw_vendor === 'Trezor') {
            this.firmwareType = types_1.FirmwareType.Regular;
        }
        else if (this.getMode() !== 'bootloader') {
            this.firmwareType =
                feat.capabilities &&
                    feat.capabilities.length > 0 &&
                    !feat.capabilities.includes('Capability_Bitcoin_like')
                    ? types_1.FirmwareType.BitcoinOnly
                    : types_1.FirmwareType.Regular;
        }
        const deviceInfo = (_d = models_1.models[feat.internal_model]) !== null && _d !== void 0 ? _d : {
            name: `Unknown ${feat.internal_model}`,
            colors: {},
        };
        this.name = deviceInfo.name;
        if (feat === null || feat === void 0 ? void 0 : feat.unit_color) {
            const deviceUnitColor = feat.unit_color.toString();
            if (deviceUnitColor in deviceInfo.colors) {
                this.color = deviceInfo.colors[deviceUnitColor];
            }
        }
    }
    isUnacquired() {
        return this.features === undefined;
    }
    disconnect() {
        _log.debug('Disconnect cleanup');
        this.activitySessionID = null;
        this.interruptionFromUser(constants_1.ERRORS.TypedError('Device_Disconnected'));
        delete this.runPromise;
    }
    isBootloader() {
        return this.features && !!this.features.bootloader_mode;
    }
    isInitialized() {
        return this.features && !!this.features.initialized;
    }
    isSeedless() {
        return this.features && !!this.features.no_backup;
    }
    isInconsistent() {
        return this.inconsistent;
    }
    getVersion() {
        if (!this.features)
            return [];
        return [
            this.features.major_version,
            this.features.minor_version,
            this.features.patch_version,
        ];
    }
    atLeast(versions) {
        if (!this.features)
            return false;
        const modelVersion = typeof versions === 'string' ? versions : versions[this.features.major_version - 1];
        return utils_3.versionUtils.isNewerOrEqual(this.getVersion().join('.'), modelVersion);
    }
    isUsed() {
        return typeof this.originalDescriptor.session === 'string';
    }
    isUsedHere() {
        return this.isUsed() && this.originalDescriptor.session === this.activitySessionID;
    }
    isUsedElsewhere() {
        return this.isUsed() && !this.isUsedHere();
    }
    isRunning() {
        return !!this.runPromise;
    }
    isLoaded() {
        return this.loaded;
    }
    waitForFirstRun() {
        return this.firstRunPromise.promise;
    }
    getDevicePath() {
        return this.originalDescriptor.path;
    }
    isT1() {
        return this.features ? this.features.major_version === 1 : false;
    }
    hasUnexpectedMode(allow, require) {
        if (this.features) {
            if (this.isBootloader() && !allow.includes(events_1.UI.BOOTLOADER)) {
                return events_1.UI.BOOTLOADER;
            }
            if (!this.isInitialized() && !allow.includes(events_1.UI.INITIALIZE)) {
                return events_1.UI.INITIALIZE;
            }
            if (this.isSeedless() && !allow.includes(events_1.UI.SEEDLESS)) {
                return events_1.UI.SEEDLESS;
            }
            if (!this.isBootloader() && require.includes(events_1.UI.BOOTLOADER)) {
                return events_1.UI.NOT_IN_BOOTLOADER;
            }
        }
        return null;
    }
    dispose() {
        this.removeAllListeners();
        if (this.isUsedHere() && this.activitySessionID) {
            try {
                if (this.commands) {
                    this.commands.cancel();
                }
                return this.transport.release({
                    session: this.activitySessionID,
                    path: this.originalDescriptor.path,
                    onClose: true,
                });
            }
            catch (err) {
            }
        }
    }
    getMode() {
        if (this.features.bootloader_mode)
            return 'bootloader';
        if (!this.features.initialized)
            return 'initialize';
        if (this.features.no_backup)
            return 'seedless';
        return 'normal';
    }
    toMessageObject() {
        if (this.unreadableError) {
            return {
                type: 'unreadable',
                path: this.originalDescriptor.path,
                error: this.unreadableError,
                label: 'Unreadable device',
                name: this.name,
            };
        }
        if (this.isUnacquired()) {
            return {
                type: 'unacquired',
                path: this.originalDescriptor.path,
                label: 'Unacquired device',
                name: this.name,
            };
        }
        const defaultLabel = 'My Trezor';
        const label = this.features.label === '' || !this.features.label ? defaultLabel : this.features.label;
        let status = this.isUsedElsewhere() ? 'occupied' : 'available';
        if (this.featuresNeedsReload)
            status = 'used';
        return {
            type: 'acquired',
            id: this.features.device_id || null,
            path: this.originalDescriptor.path,
            label,
            state: this.getExternalState(),
            status,
            mode: this.getMode(),
            name: this.name,
            color: this.color,
            firmware: this.firmwareStatus,
            firmwareRelease: this.firmwareRelease,
            firmwareType: this.firmwareType,
            features: this.features,
            unavailableCapabilities: this.unavailableCapabilities,
            availableTranslations: this.availableTranslations,
        };
    }
    async legacyForceRelease() {
        if (this.isUsedHere()) {
            await this.acquire();
            await this.getFeatures();
            await this.release();
        }
    }
}
exports.Device = Device;
//# sourceMappingURL=Device.js.map