import { Transport } from '@trezor/transport';
import { MessagesSchema as Messages } from '@trezor/protobuf';
import type { Device } from './Device';
import type { CoinInfo, BitcoinNetworkInfo } from '../types';
import type { HDNodeResponse } from '../types/api/getPublicKey';
type MessageType = Messages.MessageType;
type MessageKey = keyof MessageType;
export type TypedResponseMessage<T extends MessageKey> = {
    type: T;
    message: MessageType[T];
};
type TypedCallResponseMap = {
    [K in keyof MessageType]: TypedResponseMessage<K>;
};
type DefaultMessageResponse = TypedCallResponseMap[keyof MessageType];
export type PassphrasePromptResponse = {
    passphrase?: string;
    passphraseOnDevice?: boolean;
    cache?: boolean;
};
export declare class DeviceCommands {
    device: Device;
    transport: Transport;
    sessionId: string;
    disposed: boolean;
    callPromise?: ReturnType<Transport['call']>;
    _cancelableRequest?: (error?: any) => void;
    _cancelableRequestBySend?: boolean;
    constructor(device: Device, transport: Transport, sessionId: string);
    dispose(): void;
    isDisposed(): boolean;
    unlockPath(params?: Messages.UnlockPath): Promise<TypedResponseMessage<"UnlockedPathRequest">>;
    getPublicKey(params: Messages.GetPublicKey, unlockPath?: Messages.UnlockPath): Promise<{
        descriptor?: string | undefined;
        root_fingerprint?: number | undefined;
        node: {
            private_key?: string | undefined;
            public_key: string;
            depth: number;
            fingerprint: number;
            child_num: number;
            chain_code: string;
        };
        xpub: string;
    }>;
    getHDNode(params: Messages.GetPublicKey, options?: {
        coinInfo?: BitcoinNetworkInfo;
        validation?: boolean;
        unlockPath?: Messages.UnlockPath;
    }): Promise<{
        xpubSegwit?: string | undefined;
        descriptorChecksum?: string | undefined;
        path: number[];
        publicKey: string;
        serializedPath: string;
        depth: number;
        fingerprint: number;
        chainCode: string;
        childNum: number;
        xpub: string;
    }>;
    getBitcoinHDNode(path: number[], coinInfo?: BitcoinNetworkInfo, validation?: boolean): Promise<{
        xpubSegwit?: string | undefined;
        descriptorChecksum?: string | undefined;
        path: number[];
        publicKey: string;
        serializedPath: string;
        depth: number;
        fingerprint: number;
        chainCode: string;
        childNum: number;
        xpub: string;
    }>;
    getAddress({ address_n, show_display, multisig, script_type, chunkify }: Messages.GetAddress, coinInfo: BitcoinNetworkInfo): Promise<{
        path: number[];
        serializedPath: string;
        address: string;
    }>;
    ethereumGetAddress({ address_n, show_display, encoded_network, chunkify, }: Messages.EthereumGetAddress): Promise<{
        path: number[];
        serializedPath: string;
        address: string;
    }>;
    ethereumGetPublicKey({ address_n, show_display, }: Messages.EthereumGetPublicKey): Promise<HDNodeResponse>;
    preauthorize(throwError: boolean): Promise<boolean>;
    getDeviceState(networkType?: string): Promise<string>;
    private call;
    typedCall<T extends MessageKey, R extends MessageKey[]>(type: T, resType: R, msg?: MessageType[T]): Promise<TypedCallResponseMap[R[number]]>;
    typedCall<T extends MessageKey, R extends MessageKey>(type: T, resType: R, msg?: MessageType[T]): Promise<TypedResponseMessage<R>>;
    _commonCall(type: MessageKey, msg?: DefaultMessageResponse['message']): Promise<DefaultMessageResponse>;
    _filterCommonTypes(res: DefaultMessageResponse): Promise<DefaultMessageResponse>;
    _getAddressForNetworkType(networkType?: string): Promise<string>;
    _promptPin(type?: Messages.PinMatrixRequestType): Promise<string>;
    _promptPassphrase(): Promise<PassphrasePromptResponse>;
    _promptWord(type: Messages.WordRequestType): Promise<string>;
    getAccountDescriptor(coinInfo: CoinInfo, indexOrPath: number | number[], derivationType?: Messages.CardanoDerivationType): Promise<{
        descriptor: string;
        legacyXpub?: string;
        address_n: number[];
        descriptorChecksum?: string;
    }>;
    cancel(): Promise<void>;
}
export type TypedCall = DeviceCommands['typedCall'];
export {};
//# sourceMappingURL=DeviceCommands.d.ts.map