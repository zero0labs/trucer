"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UdpApi = void 0;
const tslib_1 = require("tslib");
const dgram_1 = tslib_1.__importDefault(require("dgram"));
const utils_1 = require("@trezor/utils");
const abstract_1 = require("./abstract");
const ERRORS = tslib_1.__importStar(require("../errors"));
class UdpApi extends abstract_1.AbstractApi {
    constructor({ logger }) {
        super({ logger });
        this.interface = dgram_1.default.createSocket('udp4');
        this.communicating = false;
    }
    write(path, buffer) {
        const [hostname, port] = path.split(':');
        return new Promise(resolve => {
            this.interface.send(buffer, Number.parseInt(port, 10), hostname, err => {
                if (err) {
                    this.logger.error(err.message);
                    return resolve(this.error({
                        error: ERRORS.INTERFACE_DATA_TRANSFER,
                        message: err.message,
                    }));
                }
                return resolve(this.success(undefined));
            });
        });
    }
    read(_path) {
        this.communicating = true;
        return new Promise(resolve => {
            const onError = (err) => {
                this.logger.error(err.message);
                resolve(this.error({
                    error: ERRORS.INTERFACE_DATA_TRANSFER,
                    message: err.message,
                }));
                this.interface.removeListener('error', onError);
                this.interface.removeListener('message', onMessage);
            };
            const onMessage = (message, _info) => {
                if (message.toString() === 'PONGPONG') {
                    return;
                }
                this.interface.removeListener('error', onError);
                this.interface.removeListener('message', onMessage);
                resolve(this.success(message));
            };
            this.interface.addListener('error', onError);
            this.interface.addListener('message', onMessage);
        }).finally(() => {
            this.communicating = false;
        });
    }
    ping(path) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.write(path, Buffer.from('PINGPING'));
            const pinged = new Promise(resolve => {
                const onMessage = (message, _info) => {
                    if (message.toString() === 'PONGPONG') {
                        resolve(true);
                        this.interface.removeListener('message', onMessage);
                        clearTimeout(timeout);
                    }
                };
                this.interface.addListener('message', onMessage);
                const timeout = setTimeout(() => {
                    this.interface.removeListener('message', onMessage);
                    resolve(false);
                }, this.communicating ? 10000 : 500);
            });
            return pinged;
        });
    }
    enumerate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const paths = ['127.0.0.1:21324'];
            const enumerateResult = yield Promise.all(paths.map(path => this.ping(path).then(pinged => (pinged ? path : undefined)))).then(res => res.filter(utils_1.isNotUndefined));
            return this.success(enumerateResult);
        });
    }
    openDevice(_path, _first) {
        return Promise.resolve(this.success(undefined));
    }
    closeDevice(_path) {
        return Promise.resolve(this.success(undefined));
    }
}
exports.UdpApi = UdpApi;
//# sourceMappingURL=udp.js.map