"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionsBackground = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@trezor/utils");
const utils_2 = require("@trezor/utils");
const ERRORS = tslib_1.__importStar(require("../errors"));
const lockDuration = 1000 * 4;
class SessionsBackground extends utils_2.TypedEmitter {
    constructor() {
        super(...arguments);
        this.sessions = {};
        this.locksQueue = [];
        this.locksTimeoutQueue = [];
        this.lastSession = 0;
    }
    handleMessage(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                switch (message.type) {
                    case 'handshake':
                        result = this.handshake();
                        break;
                    case 'enumerateIntent':
                        result = yield this.enumerateIntent();
                        break;
                    case 'enumerateDone':
                        result = yield this.enumerateDone(message.payload);
                        break;
                    case 'acquireIntent':
                        result = yield this.acquireIntent(message.payload);
                        break;
                    case 'acquireDone':
                        result = yield this.acquireDone(message.payload);
                        break;
                    case 'getSessions':
                        result = yield this.getSessions();
                        break;
                    case 'releaseIntent':
                        result = yield this.releaseIntent(message.payload);
                        break;
                    case 'releaseDone':
                        result = yield this.releaseDone(message.payload);
                        break;
                    case 'getPathBySession':
                        result = this.getPathBySession(message.payload);
                        break;
                    default:
                        throw new Error(ERRORS.UNEXPECTED_ERROR);
                }
                return Object.assign(Object.assign({}, result), { id: message.id });
            }
            catch (err) {
                return Object.assign(Object.assign({}, this.error(ERRORS.UNEXPECTED_ERROR)), { id: message.type });
            }
            finally {
                if (result && result.success && result.payload && 'descriptors' in result.payload) {
                    const { descriptors } = result.payload;
                    setTimeout(() => this.emit('descriptors', descriptors), 0);
                }
            }
        });
    }
    handshake() {
        return this.success(undefined);
    }
    enumerateIntent() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.waitInQueue();
            return this.success({ sessions: this.sessions });
        });
    }
    enumerateDone(payload) {
        this.clearLock();
        const disconnectedDevices = this.filterDisconnectedDevices(this.sessionsToDescriptors(), payload.paths);
        disconnectedDevices.forEach(d => {
            delete this.sessions[d.path];
        });
        payload.paths.forEach(d => {
            if (!this.sessions[d]) {
                this.sessions[d] = null;
            }
        });
        const descriptors = this.sessionsToDescriptors();
        return Promise.resolve(this.success({
            sessions: this.sessions,
            descriptors,
        }));
    }
    acquireIntent(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const previous = this.sessions[payload.path];
            if (payload.previous && payload.previous !== previous) {
                return this.error(ERRORS.SESSION_WRONG_PREVIOUS);
            }
            yield this.waitInQueue();
            if (previous !== this.sessions[payload.path]) {
                this.clearLock();
                return this.error(ERRORS.SESSION_WRONG_PREVIOUS);
            }
            const unconfirmedSessions = JSON.parse(JSON.stringify(this.sessions));
            const id = `${this.getNewSessionId()}`;
            unconfirmedSessions[payload.path] = id;
            const descriptors = this.sessionsToDescriptors(unconfirmedSessions);
            return this.success({
                session: id,
                descriptors,
            });
        });
    }
    acquireDone(payload) {
        this.clearLock();
        this.sessions[payload.path] = `${this.lastSession}`;
        const descriptors = this.sessionsToDescriptors();
        return Promise.resolve(this.success({
            descriptors,
        }));
    }
    releaseIntent(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const path = this.getPathFromSessions({ session: payload.session });
            if (!path) {
                return this.error(ERRORS.SESSION_NOT_FOUND);
            }
            yield this.waitInQueue();
            return this.success({ path });
        });
    }
    releaseDone(payload) {
        this.sessions[payload.path] = null;
        this.clearLock();
        const descriptors = this.sessionsToDescriptors();
        return Promise.resolve(this.success({ descriptors }));
    }
    getSessions() {
        return Promise.resolve(this.success({ sessions: this.sessions }));
    }
    getPathBySession({ session }) {
        const path = this.getPathFromSessions({ session });
        if (!path) {
            return this.error(ERRORS.SESSION_NOT_FOUND);
        }
        return this.success({ path });
    }
    getPathFromSessions({ session }) {
        let path;
        Object.keys(this.sessions).forEach(pathKey => {
            if (this.sessions[pathKey] === session) {
                path = pathKey;
            }
        });
        return path;
    }
    startLock() {
        const dfd = (0, utils_1.createDeferred)();
        const timeout = setTimeout(() => {
            dfd.resolve(undefined);
        }, lockDuration);
        this.locksQueue.push(dfd);
        this.locksTimeoutQueue.push(timeout);
        return this.locksQueue.length - 1;
    }
    clearLock() {
        const lock = this.locksQueue[0];
        if (lock) {
            this.locksQueue[0].resolve(undefined);
            this.locksQueue.shift();
            clearTimeout(this.locksTimeoutQueue[0]);
            this.locksTimeoutQueue.shift();
        }
        else {
            console.warn('empty lock queue');
        }
    }
    waitForUnlocked(myIndex) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (myIndex > 0) {
                const beforeMe = this.locksQueue.slice(0, myIndex);
                if (beforeMe.length) {
                    yield Promise.all(beforeMe.map(dfd => dfd.promise));
                }
            }
        });
    }
    waitInQueue() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const myIndex = this.startLock();
            yield this.waitForUnlocked(myIndex);
        });
    }
    getNewSessionId() {
        this.lastSession++;
        return this.lastSession;
    }
    sessionsToDescriptors(sessions) {
        return Object.entries(sessions || this.sessions).map(obj => ({
            path: obj[0],
            session: obj[1],
        }));
    }
    filterDisconnectedDevices(prevDevices, paths) {
        return prevDevices.filter(d => !paths.find(p => d.path === p));
    }
    success(payload) {
        return {
            success: true,
            payload,
        };
    }
    error(error) {
        return {
            success: false,
            error,
        };
    }
}
exports.SessionsBackground = SessionsBackground;
//# sourceMappingURL=background.js.map