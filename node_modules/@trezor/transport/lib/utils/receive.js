"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.receiveAndParse = exports.receive = void 0;
const tslib_1 = require("tslib");
const protobuf_1 = require("@trezor/protobuf");
function receiveRest(result, receiver, offset, expectedLength) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (offset >= expectedLength) {
            return;
        }
        const data = yield receiver();
        if (data == null) {
            throw new Error('Received no data.');
        }
        const length = offset + data.byteLength - 1;
        Buffer.from(data).copy(result, offset, 1, length);
        return receiveRest(result, receiver, length, expectedLength);
    });
}
function receiveBuffer(receiver, decoder) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const data = yield receiver();
        const { length, typeId, buffer } = decoder(data);
        const result = Buffer.alloc(length);
        if (length) {
            buffer.copy(result);
        }
        yield receiveRest(result, receiver, buffer.length, length);
        return { received: result, typeId };
    });
}
function receive(receiver, decoder) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { received, typeId } = yield receiveBuffer(receiver, decoder);
        return {
            typeId,
            buffer: received,
        };
    });
}
exports.receive = receive;
function receiveAndParse(messages, receiver, decoder) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { buffer, typeId } = yield receive(receiver, decoder);
        const { Message, messageName } = (0, protobuf_1.createMessageFromType)(messages, typeId);
        const message = (0, protobuf_1.decode)(Message, buffer);
        return {
            message,
            type: messageName,
        };
    });
}
exports.receiveAndParse = receiveAndParse;
//# sourceMappingURL=receive.js.map